/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: cosmos/tx/v1beta1/tx.proto */

#ifndef PROTOBUF_C_cosmos_2ftx_2fv1beta1_2ftx_2eproto__INCLUDED
#define PROTOBUF_C_cosmos_2ftx_2fv1beta1_2ftx_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1004001 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif

#include "gogoproto/gogo.pb-c.h"
#include "cosmos/crypto/multisig/v1beta1/multisig.pb-c.h"
#include "cosmos/base/v1beta1/coin.pb-c.h"
#include "cosmos/tx/signing/v1beta1/signing.pb-c.h"
#include "google/protobuf/any.pb-c.h"
#include "cosmos_proto/cosmos.pb-c.h"

typedef struct Cosmos__Tx__V1beta1__Tx Cosmos__Tx__V1beta1__Tx;
typedef struct Cosmos__Tx__V1beta1__TxRaw Cosmos__Tx__V1beta1__TxRaw;
typedef struct Cosmos__Tx__V1beta1__SignDoc Cosmos__Tx__V1beta1__SignDoc;
typedef struct Cosmos__Tx__V1beta1__SignDocDirectAux Cosmos__Tx__V1beta1__SignDocDirectAux;
typedef struct Cosmos__Tx__V1beta1__TxBody Cosmos__Tx__V1beta1__TxBody;
typedef struct Cosmos__Tx__V1beta1__AuthInfo Cosmos__Tx__V1beta1__AuthInfo;
typedef struct Cosmos__Tx__V1beta1__SignerInfo Cosmos__Tx__V1beta1__SignerInfo;
typedef struct Cosmos__Tx__V1beta1__ModeInfo Cosmos__Tx__V1beta1__ModeInfo;
typedef struct Cosmos__Tx__V1beta1__ModeInfo__Single Cosmos__Tx__V1beta1__ModeInfo__Single;
typedef struct Cosmos__Tx__V1beta1__ModeInfo__Multi Cosmos__Tx__V1beta1__ModeInfo__Multi;
typedef struct Cosmos__Tx__V1beta1__Fee Cosmos__Tx__V1beta1__Fee;
typedef struct Cosmos__Tx__V1beta1__Tip Cosmos__Tx__V1beta1__Tip;
typedef struct Cosmos__Tx__V1beta1__AuxSignerData Cosmos__Tx__V1beta1__AuxSignerData;


/* --- enums --- */


/* --- messages --- */

/*
 * Tx is the standard type used for broadcasting transactions.
 */
struct  Cosmos__Tx__V1beta1__Tx
{
  ProtobufCMessage base;
  /*
   * body is the processable content of the transaction
   */
  Cosmos__Tx__V1beta1__TxBody *body;
  /*
   * auth_info is the authorization related content of the transaction,
   * specifically signers, signer modes and fee
   */
  Cosmos__Tx__V1beta1__AuthInfo *auth_info;
  /*
   * signatures is a list of signatures that matches the length and order of
   * AuthInfo's signer_infos to allow connecting signature meta information like
   * public key and signing mode by position.
   */
  size_t n_signatures;
  ProtobufCBinaryData *signatures;
};
#define COSMOS__TX__V1BETA1__TX__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__tx__v1beta1__tx__descriptor) \
    , NULL, NULL, 0,NULL }


/*
 * TxRaw is a variant of Tx that pins the signer's exact binary representation
 * of body and auth_info. This is used for signing, broadcasting and
 * verification. The binary `serialize(tx: TxRaw)` is stored in Tendermint and
 * the hash `sha256(serialize(tx: TxRaw))` becomes the "txhash", commonly used
 * as the transaction ID.
 */
struct  Cosmos__Tx__V1beta1__TxRaw
{
  ProtobufCMessage base;
  /*
   * body_bytes is a protobuf serialization of a TxBody that matches the
   * representation in SignDoc.
   */
  ProtobufCBinaryData body_bytes;
  /*
   * auth_info_bytes is a protobuf serialization of an AuthInfo that matches the
   * representation in SignDoc.
   */
  ProtobufCBinaryData auth_info_bytes;
  /*
   * signatures is a list of signatures that matches the length and order of
   * AuthInfo's signer_infos to allow connecting signature meta information like
   * public key and signing mode by position.
   */
  size_t n_signatures;
  ProtobufCBinaryData *signatures;
};
#define COSMOS__TX__V1BETA1__TX_RAW__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__tx__v1beta1__tx_raw__descriptor) \
    , {0,NULL}, {0,NULL}, 0,NULL }


/*
 * SignDoc is the type used for generating sign bytes for SIGN_MODE_DIRECT.
 */
struct  Cosmos__Tx__V1beta1__SignDoc
{
  ProtobufCMessage base;
  /*
   * body_bytes is protobuf serialization of a TxBody that matches the
   * representation in TxRaw.
   */
  ProtobufCBinaryData body_bytes;
  /*
   * auth_info_bytes is a protobuf serialization of an AuthInfo that matches the
   * representation in TxRaw.
   */
  ProtobufCBinaryData auth_info_bytes;
  /*
   * chain_id is the unique identifier of the chain this transaction targets.
   * It prevents signed transactions from being used on another chain by an
   * attacker
   */
  char *chain_id;
  /*
   * account_number is the account number of the account in state
   */
  uint64_t account_number;
};
#define COSMOS__TX__V1BETA1__SIGN_DOC__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__tx__v1beta1__sign_doc__descriptor) \
    , {0,NULL}, {0,NULL}, (char *)protobuf_c_empty_string, 0 }


/*
 * SignDocDirectAux is the type used for generating sign bytes for
 * SIGN_MODE_DIRECT_AUX.
 * Since: cosmos-sdk 0.46
 */
struct  Cosmos__Tx__V1beta1__SignDocDirectAux
{
  ProtobufCMessage base;
  /*
   * body_bytes is protobuf serialization of a TxBody that matches the
   * representation in TxRaw.
   */
  ProtobufCBinaryData body_bytes;
  /*
   * public_key is the public key of the signing account.
   */
  Google__Protobuf__Any *public_key;
  /*
   * chain_id is the identifier of the chain this transaction targets.
   * It prevents signed transactions from being used on another chain by an
   * attacker.
   */
  char *chain_id;
  /*
   * account_number is the account number of the account in state.
   */
  uint64_t account_number;
  /*
   * sequence is the sequence number of the signing account.
   */
  uint64_t sequence;
  /*
   * Tip is the optional tip used for transactions fees paid in another denom.
   * It should be left empty if the signer is not the tipper for this
   * transaction.
   * This field is ignored if the chain didn't enable tips, i.e. didn't add the
   * `TipDecorator` in its posthandler.
   */
  Cosmos__Tx__V1beta1__Tip *tip;
};
#define COSMOS__TX__V1BETA1__SIGN_DOC_DIRECT_AUX__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__tx__v1beta1__sign_doc_direct_aux__descriptor) \
    , {0,NULL}, NULL, (char *)protobuf_c_empty_string, 0, 0, NULL }


/*
 * TxBody is the body of a transaction that all signers sign over.
 */
struct  Cosmos__Tx__V1beta1__TxBody
{
  ProtobufCMessage base;
  /*
   * messages is a list of messages to be executed. The required signers of
   * those messages define the number and order of elements in AuthInfo's
   * signer_infos and Tx's signatures. Each required signer address is added to
   * the list only the first time it occurs.
   * By convention, the first required signer (usually from the first message)
   * is referred to as the primary signer and pays the fee for the whole
   * transaction.
   */
  size_t n_messages;
  Google__Protobuf__Any **messages;
  /*
   * memo is any arbitrary note/comment to be added to the transaction.
   * WARNING: in clients, any publicly exposed text should not be called memo,
   * but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).
   */
  char *memo;
  /*
   * timeout is the block height after which this transaction will not
   * be processed by the chain
   */
  uint64_t timeout_height;
  /*
   * extension_options are arbitrary options that can be added by chains
   * when the default options are not sufficient. If any of these are present
   * and can't be handled, the transaction will be rejected
   */
  size_t n_extension_options;
  Google__Protobuf__Any **extension_options;
  /*
   * extension_options are arbitrary options that can be added by chains
   * when the default options are not sufficient. If any of these are present
   * and can't be handled, they will be ignored
   */
  size_t n_non_critical_extension_options;
  Google__Protobuf__Any **non_critical_extension_options;
};
#define COSMOS__TX__V1BETA1__TX_BODY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__tx__v1beta1__tx_body__descriptor) \
    , 0,NULL, (char *)protobuf_c_empty_string, 0, 0,NULL, 0,NULL }


/*
 * AuthInfo describes the fee and signer modes that are used to sign a
 * transaction.
 */
struct  Cosmos__Tx__V1beta1__AuthInfo
{
  ProtobufCMessage base;
  /*
   * signer_infos defines the signing modes for the required signers. The number
   * and order of elements must match the required signers from TxBody's
   * messages. The first element is the primary signer and the one which pays
   * the fee.
   */
  size_t n_signer_infos;
  Cosmos__Tx__V1beta1__SignerInfo **signer_infos;
  /*
   * Fee is the fee and gas limit for the transaction. The first signer is the
   * primary signer and the one which pays the fee. The fee can be calculated
   * based on the cost of evaluating the body and doing signature verification
   * of the signers. This can be estimated via simulation.
   */
  Cosmos__Tx__V1beta1__Fee *fee;
  /*
   * Tip is the optional tip used for transactions fees paid in another denom.
   * This field is ignored if the chain didn't enable tips, i.e. didn't add the
   * `TipDecorator` in its posthandler.
   * Since: cosmos-sdk 0.46
   */
  Cosmos__Tx__V1beta1__Tip *tip;
};
#define COSMOS__TX__V1BETA1__AUTH_INFO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__tx__v1beta1__auth_info__descriptor) \
    , 0,NULL, NULL, NULL }


/*
 * SignerInfo describes the public key and signing mode of a single top-level
 * signer.
 */
struct  Cosmos__Tx__V1beta1__SignerInfo
{
  ProtobufCMessage base;
  /*
   * public_key is the public key of the signer. It is optional for accounts
   * that already exist in state. If unset, the verifier can use the required \
   * signer address for this position and lookup the public key.
   */
  Google__Protobuf__Any *public_key;
  /*
   * mode_info describes the signing mode of the signer and is a nested
   * structure to support nested multisig pubkey's
   */
  Cosmos__Tx__V1beta1__ModeInfo *mode_info;
  /*
   * sequence is the sequence of the account, which describes the
   * number of committed transactions signed by a given address. It is used to
   * prevent replay attacks.
   */
  uint64_t sequence;
};
#define COSMOS__TX__V1BETA1__SIGNER_INFO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__tx__v1beta1__signer_info__descriptor) \
    , NULL, NULL, 0 }


/*
 * Single is the mode info for a single signer. It is structured as a message
 * to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the
 * future
 */
struct  Cosmos__Tx__V1beta1__ModeInfo__Single
{
  ProtobufCMessage base;
  /*
   * mode is the signing mode of the single signer
   */
  Cosmos__Tx__Signing__V1beta1__SignMode mode;
};
#define COSMOS__TX__V1BETA1__MODE_INFO__SINGLE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__tx__v1beta1__mode_info__single__descriptor) \
    , COSMOS__TX__SIGNING__V1BETA1__SIGN_MODE__SIGN_MODE_UNSPECIFIED }


/*
 * Multi is the mode info for a multisig public key
 */
struct  Cosmos__Tx__V1beta1__ModeInfo__Multi
{
  ProtobufCMessage base;
  /*
   * bitarray specifies which keys within the multisig are signing
   */
  Cosmos__Crypto__Multisig__V1beta1__CompactBitArray *bitarray;
  /*
   * mode_infos is the corresponding modes of the signers of the multisig
   * which could include nested multisig public keys
   */
  size_t n_mode_infos;
  Cosmos__Tx__V1beta1__ModeInfo **mode_infos;
};
#define COSMOS__TX__V1BETA1__MODE_INFO__MULTI__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__tx__v1beta1__mode_info__multi__descriptor) \
    , NULL, 0,NULL }


typedef enum {
  COSMOS__TX__V1BETA1__MODE_INFO__SUM__NOT_SET = 0,
  COSMOS__TX__V1BETA1__MODE_INFO__SUM_SINGLE = 1,
  COSMOS__TX__V1BETA1__MODE_INFO__SUM_MULTI = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COSMOS__TX__V1BETA1__MODE_INFO__SUM__CASE)
} Cosmos__Tx__V1beta1__ModeInfo__SumCase;

/*
 * ModeInfo describes the signing mode of a single or nested multisig signer.
 */
struct  Cosmos__Tx__V1beta1__ModeInfo
{
  ProtobufCMessage base;
  Cosmos__Tx__V1beta1__ModeInfo__SumCase sum_case;
  union {
    /*
     * single represents a single signer
     */
    Cosmos__Tx__V1beta1__ModeInfo__Single *single;
    /*
     * multi represents a nested multisig signer
     */
    Cosmos__Tx__V1beta1__ModeInfo__Multi *multi;
  };
};
#define COSMOS__TX__V1BETA1__MODE_INFO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__tx__v1beta1__mode_info__descriptor) \
    , COSMOS__TX__V1BETA1__MODE_INFO__SUM__NOT_SET, {0} }


/*
 * Fee includes the amount of coins paid in fees and the maximum
 * gas to be used by the transaction. The ratio yields an effective "gasprice",
 * which must be above some miminum to be accepted into the mempool.
 */
struct  Cosmos__Tx__V1beta1__Fee
{
  ProtobufCMessage base;
  /*
   * amount is the amount of coins to be paid as a fee
   */
  size_t n_amount;
  Cosmos__Base__V1beta1__Coin **amount;
  /*
   * gas_limit is the maximum gas that can be used in transaction processing
   * before an out of gas error occurs
   */
  uint64_t gas_limit;
  /*
   * if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.
   * the payer must be a tx signer (and thus have signed this field in AuthInfo).
   * setting this field does *not* change the ordering of required signers for the transaction.
   */
  char *payer;
  /*
   * if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used
   * to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does
   * not support fee grants, this will fail
   */
  char *granter;
};
#define COSMOS__TX__V1BETA1__FEE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__tx__v1beta1__fee__descriptor) \
    , 0,NULL, 0, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string }


/*
 * Tip is the tip used for meta-transactions.
 * Since: cosmos-sdk 0.46
 */
struct  Cosmos__Tx__V1beta1__Tip
{
  ProtobufCMessage base;
  /*
   * amount is the amount of the tip
   */
  size_t n_amount;
  Cosmos__Base__V1beta1__Coin **amount;
  /*
   * tipper is the address of the account paying for the tip
   */
  char *tipper;
};
#define COSMOS__TX__V1BETA1__TIP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__tx__v1beta1__tip__descriptor) \
    , 0,NULL, (char *)protobuf_c_empty_string }


/*
 * AuxSignerData is the intermediary format that an auxiliary signer (e.g. a
 * tipper) builds and sends to the fee payer (who will build and broadcast the
 * actual tx). AuxSignerData is not a valid tx in itself, and will be rejected
 * by the node if sent directly as-is.
 * Since: cosmos-sdk 0.46
 */
struct  Cosmos__Tx__V1beta1__AuxSignerData
{
  ProtobufCMessage base;
  /*
   * address is the bech32-encoded address of the auxiliary signer. If using
   * AuxSignerData across different chains, the bech32 prefix of the target
   * chain (where the final transaction is broadcasted) should be used.
   */
  char *address;
  /*
   * sign_doc is the SIGN_MODE_DIRECT_AUX sign doc that the auxiliary signer
   * signs. Note: we use the same sign doc even if we're signing with
   * LEGACY_AMINO_JSON.
   */
  Cosmos__Tx__V1beta1__SignDocDirectAux *sign_doc;
  /*
   * mode is the signing mode of the single signer.
   */
  Cosmos__Tx__Signing__V1beta1__SignMode mode;
  /*
   * sig is the signature of the sign doc.
   */
  ProtobufCBinaryData sig;
};
#define COSMOS__TX__V1BETA1__AUX_SIGNER_DATA__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__tx__v1beta1__aux_signer_data__descriptor) \
    , (char *)protobuf_c_empty_string, NULL, COSMOS__TX__SIGNING__V1BETA1__SIGN_MODE__SIGN_MODE_UNSPECIFIED, {0,NULL} }


/* Cosmos__Tx__V1beta1__Tx methods */
void   cosmos__tx__v1beta1__tx__init
                     (Cosmos__Tx__V1beta1__Tx         *message);
size_t cosmos__tx__v1beta1__tx__get_packed_size
                     (const Cosmos__Tx__V1beta1__Tx   *message);
size_t cosmos__tx__v1beta1__tx__pack
                     (const Cosmos__Tx__V1beta1__Tx   *message,
                      uint8_t             *out);
size_t cosmos__tx__v1beta1__tx__pack_to_buffer
                     (const Cosmos__Tx__V1beta1__Tx   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Tx__V1beta1__Tx *
       cosmos__tx__v1beta1__tx__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__tx__v1beta1__tx__free_unpacked
                     (Cosmos__Tx__V1beta1__Tx *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Tx__V1beta1__TxRaw methods */
void   cosmos__tx__v1beta1__tx_raw__init
                     (Cosmos__Tx__V1beta1__TxRaw         *message);
size_t cosmos__tx__v1beta1__tx_raw__get_packed_size
                     (const Cosmos__Tx__V1beta1__TxRaw   *message);
size_t cosmos__tx__v1beta1__tx_raw__pack
                     (const Cosmos__Tx__V1beta1__TxRaw   *message,
                      uint8_t             *out);
size_t cosmos__tx__v1beta1__tx_raw__pack_to_buffer
                     (const Cosmos__Tx__V1beta1__TxRaw   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Tx__V1beta1__TxRaw *
       cosmos__tx__v1beta1__tx_raw__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__tx__v1beta1__tx_raw__free_unpacked
                     (Cosmos__Tx__V1beta1__TxRaw *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Tx__V1beta1__SignDoc methods */
void   cosmos__tx__v1beta1__sign_doc__init
                     (Cosmos__Tx__V1beta1__SignDoc         *message);
size_t cosmos__tx__v1beta1__sign_doc__get_packed_size
                     (const Cosmos__Tx__V1beta1__SignDoc   *message);
size_t cosmos__tx__v1beta1__sign_doc__pack
                     (const Cosmos__Tx__V1beta1__SignDoc   *message,
                      uint8_t             *out);
size_t cosmos__tx__v1beta1__sign_doc__pack_to_buffer
                     (const Cosmos__Tx__V1beta1__SignDoc   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Tx__V1beta1__SignDoc *
       cosmos__tx__v1beta1__sign_doc__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__tx__v1beta1__sign_doc__free_unpacked
                     (Cosmos__Tx__V1beta1__SignDoc *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Tx__V1beta1__SignDocDirectAux methods */
void   cosmos__tx__v1beta1__sign_doc_direct_aux__init
                     (Cosmos__Tx__V1beta1__SignDocDirectAux         *message);
size_t cosmos__tx__v1beta1__sign_doc_direct_aux__get_packed_size
                     (const Cosmos__Tx__V1beta1__SignDocDirectAux   *message);
size_t cosmos__tx__v1beta1__sign_doc_direct_aux__pack
                     (const Cosmos__Tx__V1beta1__SignDocDirectAux   *message,
                      uint8_t             *out);
size_t cosmos__tx__v1beta1__sign_doc_direct_aux__pack_to_buffer
                     (const Cosmos__Tx__V1beta1__SignDocDirectAux   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Tx__V1beta1__SignDocDirectAux *
       cosmos__tx__v1beta1__sign_doc_direct_aux__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__tx__v1beta1__sign_doc_direct_aux__free_unpacked
                     (Cosmos__Tx__V1beta1__SignDocDirectAux *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Tx__V1beta1__TxBody methods */
void   cosmos__tx__v1beta1__tx_body__init
                     (Cosmos__Tx__V1beta1__TxBody         *message);
size_t cosmos__tx__v1beta1__tx_body__get_packed_size
                     (const Cosmos__Tx__V1beta1__TxBody   *message);
size_t cosmos__tx__v1beta1__tx_body__pack
                     (const Cosmos__Tx__V1beta1__TxBody   *message,
                      uint8_t             *out);
size_t cosmos__tx__v1beta1__tx_body__pack_to_buffer
                     (const Cosmos__Tx__V1beta1__TxBody   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Tx__V1beta1__TxBody *
       cosmos__tx__v1beta1__tx_body__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__tx__v1beta1__tx_body__free_unpacked
                     (Cosmos__Tx__V1beta1__TxBody *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Tx__V1beta1__AuthInfo methods */
void   cosmos__tx__v1beta1__auth_info__init
                     (Cosmos__Tx__V1beta1__AuthInfo         *message);
size_t cosmos__tx__v1beta1__auth_info__get_packed_size
                     (const Cosmos__Tx__V1beta1__AuthInfo   *message);
size_t cosmos__tx__v1beta1__auth_info__pack
                     (const Cosmos__Tx__V1beta1__AuthInfo   *message,
                      uint8_t             *out);
size_t cosmos__tx__v1beta1__auth_info__pack_to_buffer
                     (const Cosmos__Tx__V1beta1__AuthInfo   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Tx__V1beta1__AuthInfo *
       cosmos__tx__v1beta1__auth_info__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__tx__v1beta1__auth_info__free_unpacked
                     (Cosmos__Tx__V1beta1__AuthInfo *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Tx__V1beta1__SignerInfo methods */
void   cosmos__tx__v1beta1__signer_info__init
                     (Cosmos__Tx__V1beta1__SignerInfo         *message);
size_t cosmos__tx__v1beta1__signer_info__get_packed_size
                     (const Cosmos__Tx__V1beta1__SignerInfo   *message);
size_t cosmos__tx__v1beta1__signer_info__pack
                     (const Cosmos__Tx__V1beta1__SignerInfo   *message,
                      uint8_t             *out);
size_t cosmos__tx__v1beta1__signer_info__pack_to_buffer
                     (const Cosmos__Tx__V1beta1__SignerInfo   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Tx__V1beta1__SignerInfo *
       cosmos__tx__v1beta1__signer_info__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__tx__v1beta1__signer_info__free_unpacked
                     (Cosmos__Tx__V1beta1__SignerInfo *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Tx__V1beta1__ModeInfo__Single methods */
void   cosmos__tx__v1beta1__mode_info__single__init
                     (Cosmos__Tx__V1beta1__ModeInfo__Single         *message);
/* Cosmos__Tx__V1beta1__ModeInfo__Multi methods */
void   cosmos__tx__v1beta1__mode_info__multi__init
                     (Cosmos__Tx__V1beta1__ModeInfo__Multi         *message);
/* Cosmos__Tx__V1beta1__ModeInfo methods */
void   cosmos__tx__v1beta1__mode_info__init
                     (Cosmos__Tx__V1beta1__ModeInfo         *message);
size_t cosmos__tx__v1beta1__mode_info__get_packed_size
                     (const Cosmos__Tx__V1beta1__ModeInfo   *message);
size_t cosmos__tx__v1beta1__mode_info__pack
                     (const Cosmos__Tx__V1beta1__ModeInfo   *message,
                      uint8_t             *out);
size_t cosmos__tx__v1beta1__mode_info__pack_to_buffer
                     (const Cosmos__Tx__V1beta1__ModeInfo   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Tx__V1beta1__ModeInfo *
       cosmos__tx__v1beta1__mode_info__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__tx__v1beta1__mode_info__free_unpacked
                     (Cosmos__Tx__V1beta1__ModeInfo *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Tx__V1beta1__Fee methods */
void   cosmos__tx__v1beta1__fee__init
                     (Cosmos__Tx__V1beta1__Fee         *message);
size_t cosmos__tx__v1beta1__fee__get_packed_size
                     (const Cosmos__Tx__V1beta1__Fee   *message);
size_t cosmos__tx__v1beta1__fee__pack
                     (const Cosmos__Tx__V1beta1__Fee   *message,
                      uint8_t             *out);
size_t cosmos__tx__v1beta1__fee__pack_to_buffer
                     (const Cosmos__Tx__V1beta1__Fee   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Tx__V1beta1__Fee *
       cosmos__tx__v1beta1__fee__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__tx__v1beta1__fee__free_unpacked
                     (Cosmos__Tx__V1beta1__Fee *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Tx__V1beta1__Tip methods */
void   cosmos__tx__v1beta1__tip__init
                     (Cosmos__Tx__V1beta1__Tip         *message);
size_t cosmos__tx__v1beta1__tip__get_packed_size
                     (const Cosmos__Tx__V1beta1__Tip   *message);
size_t cosmos__tx__v1beta1__tip__pack
                     (const Cosmos__Tx__V1beta1__Tip   *message,
                      uint8_t             *out);
size_t cosmos__tx__v1beta1__tip__pack_to_buffer
                     (const Cosmos__Tx__V1beta1__Tip   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Tx__V1beta1__Tip *
       cosmos__tx__v1beta1__tip__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__tx__v1beta1__tip__free_unpacked
                     (Cosmos__Tx__V1beta1__Tip *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Tx__V1beta1__AuxSignerData methods */
void   cosmos__tx__v1beta1__aux_signer_data__init
                     (Cosmos__Tx__V1beta1__AuxSignerData         *message);
size_t cosmos__tx__v1beta1__aux_signer_data__get_packed_size
                     (const Cosmos__Tx__V1beta1__AuxSignerData   *message);
size_t cosmos__tx__v1beta1__aux_signer_data__pack
                     (const Cosmos__Tx__V1beta1__AuxSignerData   *message,
                      uint8_t             *out);
size_t cosmos__tx__v1beta1__aux_signer_data__pack_to_buffer
                     (const Cosmos__Tx__V1beta1__AuxSignerData   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Tx__V1beta1__AuxSignerData *
       cosmos__tx__v1beta1__aux_signer_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__tx__v1beta1__aux_signer_data__free_unpacked
                     (Cosmos__Tx__V1beta1__AuxSignerData *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Cosmos__Tx__V1beta1__Tx_Closure)
                 (const Cosmos__Tx__V1beta1__Tx *message,
                  void *closure_data);
typedef void (*Cosmos__Tx__V1beta1__TxRaw_Closure)
                 (const Cosmos__Tx__V1beta1__TxRaw *message,
                  void *closure_data);
typedef void (*Cosmos__Tx__V1beta1__SignDoc_Closure)
                 (const Cosmos__Tx__V1beta1__SignDoc *message,
                  void *closure_data);
typedef void (*Cosmos__Tx__V1beta1__SignDocDirectAux_Closure)
                 (const Cosmos__Tx__V1beta1__SignDocDirectAux *message,
                  void *closure_data);
typedef void (*Cosmos__Tx__V1beta1__TxBody_Closure)
                 (const Cosmos__Tx__V1beta1__TxBody *message,
                  void *closure_data);
typedef void (*Cosmos__Tx__V1beta1__AuthInfo_Closure)
                 (const Cosmos__Tx__V1beta1__AuthInfo *message,
                  void *closure_data);
typedef void (*Cosmos__Tx__V1beta1__SignerInfo_Closure)
                 (const Cosmos__Tx__V1beta1__SignerInfo *message,
                  void *closure_data);
typedef void (*Cosmos__Tx__V1beta1__ModeInfo__Single_Closure)
                 (const Cosmos__Tx__V1beta1__ModeInfo__Single *message,
                  void *closure_data);
typedef void (*Cosmos__Tx__V1beta1__ModeInfo__Multi_Closure)
                 (const Cosmos__Tx__V1beta1__ModeInfo__Multi *message,
                  void *closure_data);
typedef void (*Cosmos__Tx__V1beta1__ModeInfo_Closure)
                 (const Cosmos__Tx__V1beta1__ModeInfo *message,
                  void *closure_data);
typedef void (*Cosmos__Tx__V1beta1__Fee_Closure)
                 (const Cosmos__Tx__V1beta1__Fee *message,
                  void *closure_data);
typedef void (*Cosmos__Tx__V1beta1__Tip_Closure)
                 (const Cosmos__Tx__V1beta1__Tip *message,
                  void *closure_data);
typedef void (*Cosmos__Tx__V1beta1__AuxSignerData_Closure)
                 (const Cosmos__Tx__V1beta1__AuxSignerData *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor cosmos__tx__v1beta1__tx__descriptor;
extern const ProtobufCMessageDescriptor cosmos__tx__v1beta1__tx_raw__descriptor;
extern const ProtobufCMessageDescriptor cosmos__tx__v1beta1__sign_doc__descriptor;
extern const ProtobufCMessageDescriptor cosmos__tx__v1beta1__sign_doc_direct_aux__descriptor;
extern const ProtobufCMessageDescriptor cosmos__tx__v1beta1__tx_body__descriptor;
extern const ProtobufCMessageDescriptor cosmos__tx__v1beta1__auth_info__descriptor;
extern const ProtobufCMessageDescriptor cosmos__tx__v1beta1__signer_info__descriptor;
extern const ProtobufCMessageDescriptor cosmos__tx__v1beta1__mode_info__descriptor;
extern const ProtobufCMessageDescriptor cosmos__tx__v1beta1__mode_info__single__descriptor;
extern const ProtobufCMessageDescriptor cosmos__tx__v1beta1__mode_info__multi__descriptor;
extern const ProtobufCMessageDescriptor cosmos__tx__v1beta1__fee__descriptor;
extern const ProtobufCMessageDescriptor cosmos__tx__v1beta1__tip__descriptor;
extern const ProtobufCMessageDescriptor cosmos__tx__v1beta1__aux_signer_data__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_cosmos_2ftx_2fv1beta1_2ftx_2eproto__INCLUDED */
